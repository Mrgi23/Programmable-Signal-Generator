stages:
  - setup
  - build
  - test
  - deploy

workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && ($CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "develop" || $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main")'
    - if: '$CI_COMMIT_BRANCH == "develop" || $CI_COMMIT_BRANCH == "main"'

variables:
  ROOT_DIR: ${CI_PROJECT_DIR}
  BUILD_DIR: ${CI_PROJECT_DIR}/tests/build
  REPORT_DIR: ${CI_PROJECT_DIR}/reports
  COVERAGE_CPP_DIR: ${REPORT_DIR}/htmlcov/cpp
  COVERAGE_PY_DIR: ${REPORT_DIR}/htmlcov/python
  IMAGE_NAME: registry.gitlab.com/mrgi23/programmable-signal-generator/psg:latest

setup_image:
  stage: setup
  tags:
    - arm
    - raspberrypi
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_TLS_CERTDIR: ""
  rules:
    - changes:
      - Dockerfile
      - requirements.txt
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
    - docker build -t psg:latest .
    - docker tag psg:latest $IMAGE_NAME
    - docker push $IMAGE_NAME

build_cpp:
  stage: build
  tags:
    - arm
    - raspberrypi
  image: $IMAGE_NAME
  script:
    - mkdir -p ${BUILD_DIR}
    - cd ${BUILD_DIR}
    - cmake ..
    - cmake --build .
  artifacts:
    paths:
      - ${BUILD_DIR}
    expire_in: 1 hour

test_cpp:
  stage: test
  tags:
    - arm
    - raspberrypi
  image: $IMAGE_NAME
  script:
    - mkdir -p ${COVERAGE_CPP_DIR}
    - cd ${BUILD_DIR}
    - LLVM_PROFILE_FILE=coverageUnit.profraw ./unitTests
    - LLVM_PROFILE_FILE=coverageIntegration.profraw ./integrationTests
    - llvm-profdata merge -sparse coverageUnit.profraw coverageIntegration.profraw -o coverage.profdata
    - llvm-cov export ./unitTests ./integrationTests -instr-profile=coverage.profdata --ignore-filename-regex=".*armadillo_bits/.*" -format=lcov > ${COVERAGE_CPP_DIR}/coverage.lcov
    - llvm-cov report ./unitTests ./integrationTests -instr-profile=coverage.profdata --ignore-filename-regex=".*armadillo_bits/.*" > coverage.txt
    - genhtml ${COVERAGE_CPP_DIR}/coverage.lcov --output-directory ${COVERAGE_CPP_DIR}/
    - cat coverage.txt
  coverage: '/TOTAL\s+\d+\s+\d+\s+\d+\.\d+%\s+\d+\s+\d+\s+\d+\.\d+%\s+\d+\s+\d+\s+(\d+\.\d+)%/'
  artifacts:
    paths:
      - ${COVERAGE_CPP_DIR}
    expire_in: 1 hour

test_py:
  stage: test
  tags:
    - arm
    - raspberrypi
  image: $IMAGE_NAME
  script:
    - mkdir -p ${COVERAGE_PY_DIR}
    - PYTHONPATH=./src/python pytest --cov=./ --cov-report=term --cov-report=html:${COVERAGE_PY_DIR} tests/python | tee coverage.txt
  coverage: '/TOTAL\s+\d+\s+\d+\s+(\d+(?:\.\d+)?)%/'
  artifacts:
    paths:
      - ${COVERAGE_PY_DIR}
    expire_in: 1 hour

tags:
  stage: deploy
  tags:
    - arm
    - raspberrypi
  image: $IMAGE_NAME
  script:
    - git config --global user.name "GitLab CI"
    - git config --global user.email "gitlab-ci@example.com"
    - git remote set-url origin https://mrgi23:$GITLAB_TOKEN@$CI_SERVER_HOST/$CI_PROJECT_PATH.git
    - VERSION=$(echo "$CI_COMMIT_MESSAGE" | grep -Eiom1 'Release v[0-9]+\.[0-9]+\.[0-9]+')
    - |
      if [ -n "$VERSION" ]; then
        NEW_TAG=$(echo "$VERSION" | sed 's/Release //');
        git tag -d "$NEW_TAG" 2>/dev/null
        git push origin ":refs/tags/$NEW_TAG" 2>/dev/null
        git tag -a "$NEW_TAG" -m "Release $NEW_TAG";
        git push origin "$NEW_TAG";
      fi
  only:
    - main

pages:
  stage: deploy
  tags:
    - arm
    - raspberrypi
  image: $IMAGE_NAME
  script:
    - mkdir -p public
    - cp -r ${REPORT_DIR}/. public
  artifacts:
    paths:
      - public
  only:
    - main
